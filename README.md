## 튜토리얼 출처

https://product.kyobobook.co.kr/detail/S000215152090

## 갤러리 쇼핑몰 제작을 위한 개발 환경 구축

### 백엔드

| 이름               | 버전    | 용도                   |
| ------------------ | ------- | ---------------------- |
| MariaDB            | 12.1.2  | DBMS 사용              |
| JDK                | 21.0.9  | 자바 개발              |
| 스프링 부트        | 3.5.9   | API 개발               |
| MariaDB 클라이언트 | 3.3.3   | 애플리케이션의 DB 연결 |
| 스프링 데이터 JPA  | 3.3.4   | ORM 기능 활용          |
| Lombok             | 1.18.30 | 자바 코드 작성 간소화  |

### 프론트엔드

| 이름      | 버전   | 용도                          |
| --------- | ------ | ----------------------------- |
| Vue       | 3.5.26 | 싱글 페이지 애플리케이션 개발 |
| Bootstrap | 5.3.3  | 레이아웃 개발 간소화          |
| Sass      | 1.77.8 | 스타일 코드 작성 간소화       |

## 모듈 세팅

- 데이터베이스 클라이언트: 쇼핑몰 애플리케이션이 MariaDB에 접근하기 위해 필요한 도구입니다.

- 스프링 데이터 JPA: 쇼핑몰 애플리케이션 데이터베이스의 데이터를 간편하게 처리할 때 사용됩니다.

- 롬복: 쇼핑몰 애플리케이션 코드를 더 간편하게 작성하는 데 필요합니다.

## 패키지 추가

갤러리 쇼핑몰 애플리케이션의 도메인은 다음과 같습니다.

- 상품(item): 상품 데이터를 처리합니다.

- 회원(member): 회원 데이터를 처리합니다.

- 계정(account): 계정(로그인, 회원가입 등) 데이터를 처리합니다.

- 장바구니(cart); 장바구니 데이터를 처리합니다.

- 주문(order): 주문 데이터와 주문 상품에 대한 데이터를 처리합니다.

## 기능 개선

- WAS 재시작 시 로그인 사용자의 상태 정보가 초기화됩니다.

  백엔드 애플리케이션이 로그인 사용자의 상태 정보를 HTTP 세션에 저장하기 때문에 WAS가 재시작되는 경우 사용자의 상태 정보가 초기화되는 문제가 있습니다. 토큰 기술을 활용해 이 문제를 해결할 수 있습니다.

- 데이터가 원본 그래도 보관됩니다.

  주문의 카드 번호와 회원의 패스워드 데이터를 원본 그대로 저장하는 것은 보안상 위험합니다. 따라서 카드 번호와 같은 데이터를 저장할 때는 암호화하고, 패스워드와 같은 데이터를 저장할 때는 해싱을 거쳐 저장하는 편이 안전합니다.

- 입력 유효성을 검증하지 않습니다.

  사용자의 입력 내용이 유효한지 검증하지 않기 때문에 사용자가 필수로 입력해야 할 내용을 놓칠 수 있습니다. 이 때문에 입력 내용의 유효성을 검증하는 기능이 필요합니다.

- 페이지네이션 기능이 없음

  사용자의 주문 내역을 페이지로 나누지 않고 있기 때문에 데이터가 많아지면 주문 목록 페이지의 화면이 지나치게 길어질 수 있습니다. 이 때문에 데이터를 나누어 출력하는 페이지네이션 기능이 필요합니다.

## 스프링 인터셉터란?

인터셉터는 사전적으로 '중간에 가로채는 것'을 의미합니다. 스프링 인터셉터는 클라이언트와 서버가 HTTP 통신을 할 때 중간에 가로채서 특정 작업을 수행할 수 있게 하는 기능입니다.

## Axios 인터셉터란?

프론트엔드에도 인터셉토를 적용할 수 있는 기능이 Axios에서 제공하는 인터셉터입니다. Axios 인터셉터도 스프링 인터셉터와 마찬가지로 클라이언트와 서버가 HTTP 통신을 수행할 때 중간에 내용을 가로채서 어떤 기능을 실행할 수 있도록 하는 기능입니다.

## 암호화란?

대표적인 암호화 알고리즘에는 AES, RSA가 있습니다. 먼저 AES는 대칭 키 암호화 알고리즘으로, 데이터를 암호화하거나 복호화할 때 하나의 키만 사용합니다. 반면에 RSA는 비대칭 키 암호화 알고리즘으로, 프라이빗 키와 퍼블릭 키를 사용합니다.

## 해싱이란?

해싱은 데이터를 고정된 길이의 해시 값으로 변환하는 과정을 말합니다. 해시 값으로 변환된 데이터는 암호화와 달리 원본으로 복원하는 것이 거의 불가능합니다. 일반적으로 패스워드와 같이 민감한 정보를 저장하고 검증할 때 사용됩니다. 해싱 알고리즘의 종류로는 SHA-1, SHA-2 등이 있으며, 많이 사용되는 SHA-256은 SHA-2의 한 종류입니다. 그리고 이러한 해싱을 수행하는 함수를 해시 함수라고 합니다.

그런데 단순히 패스워드를 해싱하는 것만으로는 부족한 면이 있습니다. 해싱하려는 데이터가 동일하고, 적용된 알고리즘도 동일하다면 결괏값이 항상 똑같다는 것입니다. 예를 들어, 로그인 아이디는 다르지만 패스워드는 a1234567로 동일하게 사용하는 3명의 사용자가 있다고 해봅시다. 그리고 각각의 패스워드를 해시 값으로 변환하면 다음과 같이 결괏값도 동일합니다.

| id   | loginId | loginPw                                   |
| ---- | ------- | ----------------------------------------- |
| 11   | alpha   | 9626c7444717aab7a3bbdd509bcafa35a7491e94… |
| 27   | beta    | 9626c7444717aab7a3bbdd509bcafa35a7491e94… |
| 3123 | gamma   | 9626c7444717aab7a3bbdd509bcafa35a7491e94… |

그런데 만약 어떤 해커가 이 데이터를 확인한다면 3명의 사용자가 모두 동일한 패스워드를 사용한다는 것을 유추할 수 있을 것입니다. 만약 어떤 일을 계기로 사용자 한 명의 패스워드가 유출된다면 다른 2명의 사용자 계정도 탈취할 수 있다는 위험 요소가 있습니다.

또 다른 위험 요소로는 공격자가 레인보우 테이블(rainbow table)을 사용해서 원본 값을 알 수 있다는 점입니다. 레인보우 테이블은 해시 데이터에 대응하는 원본 값을 빠르게 찾기 위해 만들어진 테이블입니다.

이러한 문제를 보완하기 위해 솔트(salt)라는 개념이 등장합니다. 데이터 원본을 그대로 해싱하는 것이 아니라 어떤 값을 포함해서 해싱하는 것입니다. 이 값을 솔트라고 합니다. 예를 들어, 어떤 사용자의 패스워드인 "delta"라는 원본 값 뒤에 랜덤한 솔트 문자열 rudh472dh37sh3bg을 추가한 다음, 이 값을 해싱하는 것입니다. 이 값을 해싱하면 다음과 같이 나옵니다.

| 원본 데이터           | 해시 데이터                       |
| --------------------- | --------------------------------- |
| delta                 | 4f4a9410ffcdf895c4adb880659e9b5…  |
| deltarudh472dh37sh3bg | 7a630f13a0c87436efad3c427f141e7a… |

이렇게 하면 동일한 패스워드의 데이터가 있다고 해도 사용자마다 랜덤한 솔트 문자열이 추가되어 해싱되기 때문에 동일한 패스워드가 있는지 알 수 없게 됩니다. 또 16바이트 이상의 긴 솔트 문자열이 추가되어 해싱되기 때문에 원본 값을 찾는다는 것은 사실상 불가능에 가깝습니다.

아래 예시와 같이 각 데이터마다 솔트를 다르게 적용해 동일한 패스워드라도 다른 해시 값이 나오게 합니다. (아래 데이터 모두 원본 패스워드 값은 delta이지만 해싱된 값을 다릅니다.)

| id   | loginId | loginPw                                   | salt           |
| ---- | ------- | ----------------------------------------- | -------------- |
| 11   | alpha   | 835e088195103d1b9b3f78a86c918fbe1257866e… | R271a921512466 |
| 27   | beta    | 5541ff777cc3b2c87b4388daa6cb2cc1b751a13b… | U28aa212361231 |
| 3123 | gamma   | 2e4f2288def455868cea2eecc7c3e0ecf3346174… | T29ac373897583 |

위와 같은 데이터가 있을 때 클라이언트의 로그인 요청을 받은 서버는 다음과 같이 처리합니다.

1. 클라이언트가 요청한 로그인 아이디(예: alpha)에 해당하는 회원 정보를 조회합니다. 조회 결과가 없다면 HTTP 상태 코드 404(Not Found)를 반환합니다. 조회 결과가 있다면 다음 단계로 넘어갑니다.

2. 클라이언트가 요청한 로그인 패스워드(예: delta)와 회원 정보의 솔트(R271a921512466)를 합쳐서 해싱합니다. (예: 835e088195103d1b9b3f78a86c918fbe1257866e…)

3. 해싱된 데이터가 회원 정보의 로그인 패스워드와 일치하면 상태 코드 200(OK)을 반환하고, 일치하지 않으면 404(Not Found)을 반환합니다.

## 🛠 Tech Stack

<p align="center">
   <img src="https://skillicons.dev/icons?i=vue,bootstrap,sass" />
</p>
<p align="center">
   <img src="https://skillicons.dev/icons?i=spring" />
</p>
